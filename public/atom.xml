<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EGOISTK21&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/b030fcbaf9d8ab4c8994a597a8b1cdc5</icon>
  <subtitle>弱者抱以命，强者谦以运。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://egoistk21.xyz/"/>
  <updated>2017-09-28T01:20:46.615Z</updated>
  <id>https://egoistk21.xyz/</id>
  
  <author>
    <name>EGOISTK21</name>
    <email>egoistk21@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://egoistk21.xyz/2017/09/28/hello-world/"/>
    <id>https://egoistk21.xyz/2017/09/28/hello-world/</id>
    <published>2017-09-28T01:20:46.615Z</published>
    <updated>2017-09-28T01:20:46.615Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java笔记目录</title>
    <link href="https://egoistk21.xyz/2017/02/23/Java%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/"/>
    <id>https://egoistk21.xyz/2017/02/23/Java笔记目录/</id>
    <published>2017-02-23T01:10:47.000Z</published>
    <updated>2017-09-28T01:20:46.614Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java排序算法专题续</title>
    <link href="https://egoistk21.xyz/2017/02/17/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E7%BB%AD/"/>
    <id>https://egoistk21.xyz/2017/02/17/Java排序算法专题续/</id>
    <published>2017-02-17T07:40:01.000Z</published>
    <updated>2017-09-28T01:20:46.614Z</updated>
    
    <content type="html"><![CDATA[<p>距离上一篇博客更新已经小半年了，这期间我懒懒散散，整天沉迷于Wi-Fi暴力破解、VPS的shadowsocks配置、搭建私有云之类的奇技淫巧，深刻领悟了Linux的魅力，也终于迫于找实习的压力重新开始写代码，更博客。其实上一篇博客之后，原本有一些笔试大题的解答，但那时我还没有学得算法的皮毛，净是些暴力方法，写着写着烂尾了不好意思发布出来。等我最近学习算法的期间若想到了更好的解法，便一并贴出。</p><a id="more"></a><p>我的上一篇《Java排序算法专题》收到了好多读者的喜爱，其中仍有多处不足及错误，我会在学习的过程当中不断地进行改进。今天我给大家带来之前承诺过的几种递归排序算法的非递归实现。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Region</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> low;</div><div class="line">        <span class="keyword">int</span> high;</div><div class="line"></div><div class="line">        Region(<span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</div><div class="line">            <span class="keyword">this</span>.low = low;</div><div class="line">            <span class="keyword">this</span>.high = high;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecursiveQuickSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i, j, pivot;</div><div class="line">        Region region;</div><div class="line">        Stack&lt;Region&gt; regions = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        regions.add(<span class="keyword">new</span> Region(<span class="number">0</span>, nums.length - <span class="number">1</span>));</div><div class="line">        <span class="keyword">while</span> (!regions.empty()) &#123;</div><div class="line">            region = regions.pop();</div><div class="line">            i = region.low;</div><div class="line">            j = region.high;</div><div class="line">            pivot = nums[i];</div><div class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">                <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">                    <span class="keyword">if</span> (pivot &gt;= nums[j]) &#123;</div><div class="line">                        nums[i++] = nums[j];</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    j--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">                    <span class="keyword">if</span> (pivot &lt;= nums[i]) &#123;</div><div class="line">                        nums[j--] = nums[i];</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            nums[i] = pivot;</div><div class="line">            <span class="keyword">if</span> (i &gt; region.low + <span class="number">1</span>) regions.add(<span class="keyword">new</span> Region(region.low, i - <span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (i &lt; region.high - <span class="number">1</span>) regions.add(<span class="keyword">new</span> Region(i + <span class="number">1</span>, region.high));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;</div><div class="line">        <span class="keyword">new</span> Sort().nonRecursiveQuickSort(a);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:a) System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecursiveMergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> loop = (<span class="keyword">int</span>) Math.ceil(Math.log(nums.length)/Math.log(<span class="number">2</span>));</div><div class="line">    Stack&lt;<span class="keyword">int</span>[]&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    Stack&lt;<span class="keyword">int</span>[]&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">        <span class="keyword">int</span>[] a = &#123;num&#125;;</div><div class="line">        stack1.push(a);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (loop &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (stack1.size() &gt; <span class="number">1</span>) stack2.push(merge(stack1.pop(), stack1.pop()));</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack1.size() == <span class="number">1</span>) stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        loop--;</div><div class="line">        <span class="keyword">if</span> (loop == <span class="number">0</span>) System.arraycopy(stack2.pop(), <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</div><div class="line">        <span class="keyword">while</span> (loop &gt; <span class="number">0</span>&amp;&amp;!stack2.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (stack2.size() &gt; <span class="number">1</span>) stack1.push(merge(stack2.pop(), stack2.pop()));</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack2.size() == <span class="number">1</span>) stack1.push(stack2.pop());</div><div class="line">        &#125;</div><div class="line">        loop--;</div><div class="line">        <span class="keyword">if</span> (loop == <span class="number">0</span>) System.arraycopy(stack1.pop(), <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">    <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</div><div class="line">    <span class="keyword">int</span>[] nums3 = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + length2];</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; length1&amp;&amp;j &lt; length2) &#123;</div><div class="line">        nums3[k++] = (nums1[i] &lt; nums2[j])?nums1[i++]:nums2[j++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (i &lt; length1) &#123;</div><div class="line">        nums3[k++] = nums1[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (j &lt; length2) &#123;</div><div class="line">        nums3[k++] = nums2[j++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nums3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离上一篇博客更新已经小半年了，这期间我懒懒散散，整天沉迷于Wi-Fi暴力破解、VPS的shadowsocks配置、搭建私有云之类的奇技淫巧，深刻领悟了Linux的魅力，也终于迫于找实习的压力重新开始写代码，更博客。其实上一篇博客之后，原本有一些笔试大题的解答，但那时我还没有学得算法的皮毛，净是些暴力方法，写着写着烂尾了不好意思发布出来。等我最近学习算法的期间若想到了更好的解法，便一并贴出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
      <category term="Algorithm" scheme="https://egoistk21.xyz/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://egoistk21.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Java引用和clone方法总结</title>
    <link href="https://egoistk21.xyz/2016/10/16/Java%E5%BC%95%E7%94%A8%E5%92%8Cclone%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://egoistk21.xyz/2016/10/16/Java引用和clone方法总结/</id>
    <published>2016-10-16T09:15:36.000Z</published>
    <updated>2017-09-28T01:20:46.613Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在写WORKS APPLICATIONS的两题笔试题，就没空写博客了。现在写完了，先分享一下第一个题Magic Cube里遇到的知识点“引用和clone方法”。详细的题解请关注后续博客。</p><p>先来说说我是怎么遇到这个知识点的，在解题过程中，我写了一个包含三维数组的类和一个递归方法，大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cube</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;<span class="comment">//立方体边长</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][][] cells;<span class="comment">//立方体点阵</span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span>[][][] cells)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.len = len;</div><div class="line">        <span class="keyword">this</span>.cells = cells;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">//省略一些代码</span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//省略一些代码</span></div><div class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> N = sc.nextInt();</div><div class="line">        Cube[] smallCubes = <span class="keyword">new</span> Cube[N];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">int</span> len = sc.nextInt();</div><div class="line">            Ns = <span class="keyword">new</span> <span class="keyword">int</span>[len][len][len];</div><div class="line">System.out.println(Ns);<span class="comment">//获取Ns的哈希码</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len; l++) &#123;</div><div class="line">                        Ns[j][k][l] = sc.nextInt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            smallCubes[i] = <span class="keyword">new</span> Cube(len, Ns);</div><div class="line">System.out.println(smallCubes[i].cells);<span class="comment">//获取smallCubes[i].cells的哈希码</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行后会发现两次输出的哈希码一样，如果有多组数据（N&gt;1），那么你会发现每组数据输出两个相同的哈希码，组与组之间的哈希码不同。每组数据同样是Ns，地址却不同，这是为什么呢？别急，我们先保留这个疑惑，看看下面的情况。</p><p>因为解题需求，这时候我需要复制一个立方体：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Cube c1 = <span class="keyword">new</span> Cube(<span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][][]&#123;&#123;&#123;<span class="number">1</span>&#125;&#125;&#125;);</div><div class="line">Cube c2 = c1;</div><div class="line">System.out.println(c1);</div><div class="line">System.out.println(c2);<span class="comment">//这两句输出的哈希码一样</span></div><div class="line">c1.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]++;</div><div class="line">System.out.println(c2.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//输出2</span></div></pre></td></tr></table></figure><p>这样“复制”肯定不行，c2和c1的哈希码是一样的，即c2是指向c1的引用，改变c1的值c2的也被改变。</p><p>那上述传Ns值的时候为什么每组的Ns的哈希码不一样呢？原来是new关键字，new出来的对象都是Heap上一块新内存。JVM把程序申请的内存从逻辑上划分为四个部分，如下：</p><table><thead><tr><th>内存区域</th><th>存放内容</th></tr></thead><tbody><tr><td>Stack(栈)</td><td>8种基本数据类型值和String，如String s = “123”;这里的s</td></tr><tr><td>Heap(堆)</td><td>创建出来的对象，如String s = new String(“123”);这里的new String()</td></tr><tr><td>Data segment</td><td>静态数据常量（包含String池），如String s = “123”;这里的”123”</td></tr><tr><td>Code segment</td><td>static代码段</td></tr></tbody></table><p>然后我们结合代码和图示来分析一下程序运行时JVM中内存的动作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String s1 = <span class="string">"123"</span>;<span class="comment">//"123"被放入String池，JVM自动new字符串对象o指向"123"，s1指向o</span></div><div class="line">String s2 = <span class="string">"123"</span>;<span class="comment">//String池中存在"123"，s2指向o</span></div><div class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"123"</span>);<span class="comment">//String池中存在"123"，s2指向"123"</span></div><div class="line">System.out.println(s1 == s2);<span class="comment">//true s1和s2引用同一个对象</span></div><div class="line">System.out.println(s1 == s3);<span class="comment">//false s1和s3引用不同对象</span></div><div class="line">System.out.println(s1.equals(s3));<span class="comment">//true s1和s3值相同</span></div></pre></td></tr></table></figure><p><img src="http://of6jxo0pt.bkt.clouddn.com/Java%E5%86%85%E5%AD%981.jpg" alt="String内存分析"></p><p>同理，Cube类和其中cells三维数组在main函数中的内存分析如下：</p><p><img src="http://of6jxo0pt.bkt.clouddn.com/Java%E5%86%85%E5%AD%982.jpg" alt="三维数组和Cube数组内存分析1"></p><p>再看之前的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">    <span class="keyword">int</span> len = sc.nextInt();</div><div class="line">    Ns = <span class="keyword">new</span> <span class="keyword">int</span>[len][len][len];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len; l++) &#123;</div><div class="line">                Ns[j][k][l] = sc.nextInt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//每次传进去的Ns都是new出来的不一样的，这里每个smallCube也是new出来的不一样的</span></div><div class="line">    smallCubes[i] = <span class="keyword">new</span> Cube(len, Ns);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之前的疑惑“那传Ns值的时候为什么每组的Ns的哈希码不一样呢？”，这段代码里，每遍循环Ns都会被new分配到一块新的内存，所以每遍的Ns互相不会影响，所以每个smallCube都是独立的互不影响的。为了看的清楚点，这里我只举了两个栗子。<img src="http://of6jxo0pt.bkt.clouddn.com/Java%E5%86%85%E5%AD%983.jpg" alt="三维数组和Cube数组内存分析2"></p><p>现在我们可以回过头来考虑复制Cube对象时出现的问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Cube c1 = <span class="keyword">new</span> Cube(<span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][][]&#123;&#123;&#123;<span class="number">1</span>&#125;&#125;&#125;);</div><div class="line">Cube c2 = c1;</div><div class="line">System.out.println(c1);</div><div class="line">System.out.println(c2);<span class="comment">//这两句输出的哈希码一样</span></div><div class="line">c1.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]++;</div><div class="line">System.out.println(c2.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//输出2</span></div></pre></td></tr></table></figure><p>还是这段代码，现在我们可以画图，直观地说明为什么c1和c2的哈希码一样，而且改变c1.cells的值，c2.cells的值也会随之改变了。简单来说就是c1和c2指向了同一个引用对象。</p><p><img src="http://of6jxo0pt.bkt.clouddn.com/Java%E5%86%85%E5%AD%984.jpg" alt="三维数组和Cube数组内存分析3"></p><p>那么我们想达到的复制效果应该是这样的：</p><p><img src="http://of6jxo0pt.bkt.clouddn.com/Java%E5%86%85%E5%AD%985.jpg" alt="三维数组和Cube数组内存分析4"></p><p> 这里就不得不介绍Java提供给我们的java.lang包里面Object类的clone方法：</p><table><thead><tr><th>方法修饰词及返回值</th><th>方法名及参数</th></tr></thead><tbody><tr><td>protected  Object</td><td>clone()</td></tr><tr><td></td><td>创建并返回此对象的一个副本。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">protected Object clone()</div><div class="line">                throws CloneNotSupportedException</div><div class="line">创建并返回此对象的一个副本。“副本”的准确含义可能依赖于对象的类。这样做的目的是，对于任何对象 x，表达式：</div><div class="line">x.clone() != x</div><div class="line">为 true，表达式：</div><div class="line">x.clone().getClass() == x.getClass()</div><div class="line">也为 true，但这些并非必须要满足的要求。一般情况下：</div><div class="line">x.clone().equals(x)</div><div class="line">为 true，但这并非必须要满足的要求。</div><div class="line">按照惯例，返回的对象应该通过调用 super.clone 获得。如果一个类及其所有的超类（Object 除外）都遵守此约定，则 x.clone().getClass() == x.getClass()。</div><div class="line"></div><div class="line">按照惯例，此方法返回的对象应该独立于该对象（正被复制的对象）。要获得此独立性，在 super.clone 返回对象之前，有必要对该对象的一个或多个字段进行修改。这通常意味着要复制包含正在被复制对象的内部“深层结构”的所有可变对象，并使用对副本的引用替换对这些对象的引用。如果一个类只包含基本字段或对不变对象的引用，那么通常不需要修改 super.clone 返回的对象中的字段。</div><div class="line"></div><div class="line">Object 类的 clone 方法执行特定的复制操作。首先，如果此对象的类不能实现接口 Cloneable，则会抛出 CloneNotSupportedException。注意，所有的数组都被视为实现接口 Cloneable。否则，此方法会创建此对象的类的一个新实例，并像通过分配那样，严格使用此对象相应字段的内容初始化该对象的所有字段；这些字段的内容没有被自我复制。所以，此方法执行的是该对象的“浅表复制”，而不“深层复制”操作。</div><div class="line"></div><div class="line">Object 类本身不实现接口 Cloneable，所以在类为 Object 的对象上调用 clone 方法将会导致在运行时抛出异常。</div><div class="line"></div><div class="line">返回：</div><div class="line">此实例的一个副本。</div><div class="line">抛出：</div><div class="line">CloneNotSupportedException - 如果对象的类不支持 Cloneable 接口，则重写 clone 方法的子类也会抛出此异常，以指示无法复制某个实例。</div></pre></td></tr></table></figure><p>所以我们来尝试实现Cloneable接口重写一下clone方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cube</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][][] cells;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span>[][][] cells)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.len = len;</div><div class="line">        <span class="keyword">this</span>.cells = cells;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Cube <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">        <span class="keyword">return</span> (Cube)<span class="keyword">super</span>.clone();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Cube c1 = <span class="keyword">new</span> Cube(<span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][][]&#123;&#123;&#123;<span class="number">1</span>&#125;&#125;&#125;);</div><div class="line">        Cube c2 = c1.clone;</div><div class="line">        System.out.println(c1);</div><div class="line">        System.out.println(c2);<span class="comment">//这两句输出的哈希码终于不一样了</span></div><div class="line">        c1.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]++;</div><div class="line">        System.out.println(c2.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//输出的竟然还是2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这不可能啊，明明调用了clone方法，怎么得到的c2还是与c1引用了同一个对象。</p><p>经过搜索查阅得知，原来clone分shallow Clone(浅克隆)和deep Clone(深克隆)两种，其区别在于：对于被克隆的对象，若使用shallow Clone，则基本数据类型的成员被复制的是值，而含引用的成员被复制的是引用；若使用deep Clone，则所有成员都是以值被复制。</p><p>从前面的内存分析中我们得知Cube类中的int成员len是基本数据类型的，而三维整型数组cells则是引用类型，所以上面调用super.clone()时实现的是浅克隆，内存分析如下图：</p><p><img src="http://of6jxo0pt.bkt.clouddn.com/Java%E5%86%85%E5%AD%986.jpg" alt="三维数组和Cube数组内存分析5"></p><p>明白原因以后就简单了，现在我们来实现Cube类的deep Clone(深克隆)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Cube <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][][] cells = <span class="keyword">new</span> <span class="keyword">int</span>[len][len][len];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">            System.arraycopy(<span class="keyword">this</span>.cells[i][j], <span class="number">0</span>, cells[i][j], <span class="number">0</span>, len);</div><div class="line">            <span class="comment">//注意：多维数组本身的深克隆是对其最深维进行数组拷贝</span></div><div class="line">            <span class="comment">//当然，new出一块新内存后也可以一个一个重新赋值</span></div><div class="line">            System.arraycopy(<span class="keyword">this</span>.cells[i][j], <span class="number">0</span>, cells[i][j], <span class="number">0</span>, len);</div><div class="line"><span class="comment">//            for (int k = 0; k &lt; len; k++) &#123;</span></div><div class="line"><span class="comment">//                cells[i][j][k] = this.cells[i][j][k];</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cube(len, cells);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Cube c1 = <span class="keyword">new</span> Cube(<span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][][]&#123;&#123;&#123;<span class="number">1</span>&#125;&#125;&#125;);</div><div class="line">    Cube c2 = c1.clone;</div><div class="line">    System.out.println(c1);</div><div class="line">    System.out.println(c2);<span class="comment">//这两句输出的哈希不一样</span></div><div class="line">    c1.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]++;</div><div class="line">    System.out.println(c2.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//输出的终于是1了</span></div><div class="line">    System.out.println(c1.cells[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//输出2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>今天的分享就到此结束了，最后用两句话总结一下clone的用法：</p><p>1、什么时候使用shallow Clone，什么时候使用deep Clone，这个主要看具体对象的成员是什么性质的，基本类型还是引用类型</p><p>2、调用Clone()方法的对象所属的类必须实现Clonable接口</p><p><strong>共勉</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在写WORKS APPLICATIONS的两题笔试题，就没空写博客了。现在写完了，先分享一下第一个题Magic Cube里遇到的知识点“引用和clone方法”。详细的题解请关注后续博客。&lt;/p&gt;
&lt;p&gt;先来说说我是怎么遇到这个知识点的，在解题过程中，我写了一个包含三维数组的类和一个递归方法，大概如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cube&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len;		&lt;span class=&quot;comment&quot;&gt;//立方体边长&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][][] cells;&lt;span class=&quot;comment&quot;&gt;//立方体点阵&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cube&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][][] cells)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.len = len;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cells = cells;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//省略一些代码	&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//省略一些代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Scanner sc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Scanner(System.in);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N = sc.nextInt();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Cube[] smallCubes = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Cube[N];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = sc.nextInt();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Ns = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[len][len][len];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(Ns);&lt;span class=&quot;comment&quot;&gt;//获取Ns的哈希码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; len; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; len; k++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; l &amp;lt; len; l++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        Ns[j][k][l] = sc.nextInt();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            smallCubes[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Cube(len, Ns);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(smallCubes[i].cells);&lt;span class=&quot;comment&quot;&gt;//获取smallCubes[i].cells的哈希码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行后会发现两次输出的哈希码一样，如果有多组数据（N&amp;gt;1），那么你会发现每组数据输出两个相同的哈希码，组与组之间的哈希码不同。每组数据同样是Ns，地址却不同，这是为什么呢？别急，我们先保留这个疑惑，看看下面的情况。&lt;/p&gt;
&lt;p&gt;因为解题需求，这时候我需要复制一个立方体：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java反射二</title>
    <link href="https://egoistk21.xyz/2016/10/13/%E6%B5%85%E8%B0%88Java%E5%8F%8D%E5%B0%84%E4%BA%8C/"/>
    <id>https://egoistk21.xyz/2016/10/13/浅谈Java反射二/</id>
    <published>2016-10-13T07:40:58.000Z</published>
    <updated>2017-09-28T01:20:46.615Z</updated>
    
    <content type="html"><![CDATA[<p>昨天说的要更深入地探究一下Java反射，看了<a href="http://www.jianshu.com/users/a7f72d78fe0d" target="_blank" rel="external">嘟嘟MD </a>前辈的这篇文章<a href="http://www.jianshu.com/p/1a60d55a94cd" target="_blank" rel="external">Java基础与提高干货系列——Java反射机制</a>顿时神清气爽，觉得没多大必要再重复写他写过的了。所以今天就改成详细讲解反射的一众方法好了。</p><hr><p>先补充一下昨天所讲的创建 Class 对象的方法，其实一共有三种（昨天漏说了第三种，代码引用自<a href="http://www.jianshu.com/users/a7f72d78fe0d" target="_blank" rel="external">嘟嘟MD</a>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的</span></div><div class="line">Class c1 = Code.class;</div><div class="line"><span class="comment">//code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的</span></div><div class="line">Class c2 = code1.getClass();</div><div class="line"><span class="comment">//这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span></div><div class="line">Class c3 = Class.forName(<span class="string">"com.trigl.reflect.Code"</span>);</div></pre></td></tr></table></figure><a id="more"></a><p>下面列出 Class 类的常用方法集：</p><table><thead><tr><th>返回值</th><th>方法名及参数</th></tr></thead><tbody><tr><td>Field</td><td>getDeclaredField(String name)</td></tr><tr><td></td><td>返回一个 Field 对象，该对象反映此Class对象所表示的类或接口的指定已声明字段。</td></tr><tr><td>Field[]</td><td>getDeclaredFields()</td></tr><tr><td></td><td>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。</td></tr><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td></tr><tr><td></td><td>返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定<strong>已声明</strong>方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td></tr><tr><td></td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td>Method[]</td><td>getMethods()</td></tr><tr><td></td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr><tr><td>Field</td><td>getField(String name)</td></tr><tr><td></td><td>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。</td></tr><tr><td>Field[]</td><td>getFields()</td></tr><tr><td></td><td>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。</td></tr><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td></tr><tr><td></td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>String</td><td>getName()</td></tr><tr><td></td><td>以String的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</td></tr><tr><td>String</td><td>getSimpleName()</td></tr><tr><td></td><td>返回源代码中给出的底层类的简称。</td></tr><tr><td>Class&lt;? super T&gt;</td><td>getSuperclass()</td></tr><tr><td></td><td>返回表示此Class所表示的实体（类、接口、基本类型或 void）的超类的 Class。</td></tr><tr><td>T</td><td>newInstance()</td></tr><tr><td></td><td>创建此Class对象所表示的类的一个新实例。</td></tr></tbody></table><p>Field 类的常用方法：</p><table><thead><tr><th>返回值</th><th style="text-align:left">方法名及参数</th></tr></thead><tbody><tr><td>String</td><td style="text-align:left">getName()</td></tr><tr><td></td><td style="text-align:left">返回此 Field 对象表示的字段的名称。</td></tr></tbody></table><p>Method 类的常用方法：</p><table><thead><tr><th>返回值</th><th style="text-align:left">方法及参数</th></tr></thead><tbody><tr><td>String</td><td style="text-align:left">getName()</td></tr><tr><td></td><td style="text-align:left">以 String 形式返回此 Method 对象表示的方法名称。</td></tr><tr><td>Object</td><td style="text-align:left">invoke(Object obj, Object… args)</td></tr><tr><td></td><td style="text-align:left">对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td></tr></tbody></table><p>下面我们通过一些例子来认识一下以上的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"nameless"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">20</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" "</span> + getName() + <span class="string">" is "</span> + getAge() + <span class="string">" years old."</span>;</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaProgrammer</span> <span class="keyword">extends</span> <span class="title">Programmer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Person j = <span class="keyword">new</span> JavaProgrammer();<span class="comment">//试一下多态</span></div><div class="line">        System.out.println(j);<span class="comment">//输出JavaProgrammer nameless is 20 years old.</span></div><div class="line">        System.out.println(JavaProgrammer.class.getSimpleName());<span class="comment">//输出JavaProgrammer</span></div><div class="line">        System.out.println(JavaProgrammer.class.getSuperclass().getSuperclass().getName());<span class="comment">//输出com.egoistk.Person</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Method m = Person.class.getDeclaredMethod(<span class="string">"toString"</span>);</div><div class="line">            <span class="comment">//Method m = JavaProgrammer.class.getDeclaredMethod("toString");错误，toString方法在 JavaProgrammer 类中没有被声明</span></div><div class="line">            Method mm = JavaProgrammer.class.getMethod(<span class="string">"toString"</span>);<span class="comment">//正确，toString方法是 JavaProgrammer 类中的公共成员方法</span></div><div class="line">            System.out.println(m.invoke(JavaProgrammer.class.newInstance()));<span class="comment">//输出JavaProgrammer nameless is 20 years old. 在反射中的体现方法的动态绑定完美地解释了多态</span></div><div class="line">            System.out.println(JavaProgrammer.class.getSuperclass().getSuperclass().newInstance());<span class="comment">//输出Person nameless is 20 years old.</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果一个类中的方法是私有的我们又怎么访问，且看如何用反射调用私有属性和方法(setAccessible)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"nameless"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">20</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" "</span> + getName() + <span class="string">" is "</span> + getAge() + <span class="string">" years old."</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Method[] methods = Person.class.getDeclaredMethods();</div><div class="line">        <span class="keyword">for</span>(Method m:methods)&#123;</div><div class="line">            System.out.println(m.getName()); </div><div class="line">        &#125;<span class="comment">//输出main</span></div><div class="line">        <span class="comment">//toString</span></div><div class="line">        <span class="comment">//getName</span></div><div class="line">        <span class="comment">//setName</span></div><div class="line">        <span class="comment">//getAge</span></div><div class="line">        <span class="comment">//setAge</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Method m = Person.class.getDeclaredMethod(<span class="string">"getName"</span>);</div><div class="line">            System.out.println(m.invoke(<span class="keyword">new</span> Person()));<span class="comment">//输出nameless</span></div><div class="line">            Method mm = Person.class.getDeclaredMethod(<span class="string">"setName"</span>, String.class);</div><div class="line">            Person p = <span class="keyword">new</span> Person();</div><div class="line">            <span class="comment">//mm.invoke(p, "EGOISTK");错误，setName方法是private方法，无法调用</span></div><div class="line">            mm.setAccessible(<span class="keyword">true</span>);<span class="comment">//打开setName的权限</span></div><div class="line">            mm.invoke(p, <span class="string">"EGOISTK"</span>);<span class="comment">//可以调用了</span></div><div class="line">            System.out.println(m.invoke(p));<span class="comment">//输出EGOISTK</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>与你共勉</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天说的要更深入地探究一下Java反射，看了&lt;a href=&quot;http://www.jianshu.com/users/a7f72d78fe0d&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;嘟嘟MD &lt;/a&gt;前辈的这篇文章&lt;a href=&quot;http://www.jianshu.com/p/1a60d55a94cd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java基础与提高干货系列——Java反射机制&lt;/a&gt;顿时神清气爽，觉得没多大必要再重复写他写过的了。所以今天就改成详细讲解反射的一众方法好了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先补充一下昨天所讲的创建 Class 对象的方法，其实一共有三种（昨天漏说了第三种，代码引用自&lt;a href=&quot;http://www.jianshu.com/users/a7f72d78fe0d&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;嘟嘟MD&lt;/a&gt;）：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Class c1 = Code.class;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Class c2 = code1.getClass();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这种方法是Class类调用forName方法，通过一个类的全量限定名获得&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Class c3 = Class.forName(&lt;span class=&quot;string&quot;&gt;&quot;com.trigl.reflect.Code&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
      <category term="笔试题" scheme="https://egoistk21.xyz/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java反射一</title>
    <link href="https://egoistk21.xyz/2016/10/12/%E6%B5%85%E8%B0%88Java%E5%8F%8D%E5%B0%84%E4%B8%80/"/>
    <id>https://egoistk21.xyz/2016/10/12/浅谈Java反射一/</id>
    <published>2016-10-12T07:06:47.000Z</published>
    <updated>2017-09-28T01:20:46.615Z</updated>
    
    <content type="html"><![CDATA[<p>这学期刚开学的时候在睿思(我们学校的BBS)上看到了一个学长的求助，就收藏了，那时候自己还在搭建Hexo博客，没时间研究，昨天就去翻看了一下，原题如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要求在子类C的对象中访问其父类的父类A中的getString方法。</p><a id="more"></a><hr><p>这题不能想当然地在C类里面加一个A类的成员，要访问一个编译时根本无法预知类型的对象，那必须使用反射。那今天我们就来讲一下用反射查看类的信息。</p><p>我们先来讲一下Java中Class这个类，好比类是一批拥有共同特征的对象的抽象，Class是这些类的抽象，也就是说Class是所有类的类。Class 类的实例表示正在运行的 Java 应用程序中的类和接口。Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。例如car.getClass().getName();　还可以使用一个类字面值来获取指定类型（或 void）的 Class 对象。例如，Car.class.getName(); 有了获取正在运行的 Java 应用程序中的类的方法，接下来就好办了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</div><div class="line">        Class a = C.class.getSuperclass().getSuperclass();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Object o = a.newInstance();</div><div class="line">            A c = (A)o;</div><div class="line">            System.out.println(c.getString());</div><div class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者下面这个更好的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</div><div class="line">        Class a = C.class.getSuperclass().getSuperclass();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Method m = a.getDeclaredMethod(<span class="string">"getString"</span>,<span class="keyword">null</span>);</div><div class="line">            System.out.println(m.invoke(a.newInstance(),<span class="keyword">null</span>));</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下一篇我来讲一下怎么用反射调用私有属性和方法(setAccessible)。</p><p>晚安。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这学期刚开学的时候在睿思(我们学校的BBS)上看到了一个学长的求助，就收藏了，那时候自己还在搭建Hexo博客，没时间研究，昨天就去翻看了一下，原题如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要求在子类C的对象中访问其父类的父类A中的getString方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
      <category term="笔试题" scheme="https://egoistk21.xyz/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ZigZag Conversion</title>
    <link href="https://egoistk21.xyz/2016/09/29/ZigZag%20Conversion/"/>
    <id>https://egoistk21.xyz/2016/09/29/ZigZag Conversion/</id>
    <published>2016-09-29T07:30:11.000Z</published>
    <updated>2017-09-28T01:20:46.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锯齿形转换"><a href="#锯齿形转换" class="headerlink" title="锯齿形转换"></a>锯齿形转换</h2><p>字符串“PAYPALISHIRING”以给定数字的行数被写入锯齿形图案：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P   A   H   N</div><div class="line">A P L S I I G</div><div class="line">Y   I   R</div></pre></td></tr></table></figure><p>然后逐行读取得“PAHNAPLSIIGYIR”。</p><p>给定一个字符串，并给出了一个行数，</p><p>string convert(string text, int nRows);</p><p>如convert(“PAYPALISHIRING”, 3)这个转换应返回“PAHNAPLSIIGYIR”。</p><a id="more"></a><hr><p>这个问题困扰了我好久，因为一开始我没看懂ZigZag（锯齿形）这个词。我以为题目要求给定行数，以行数，一个，行数一个······的形式输出，9月30日折腾了一晚上就是没通过，然后，国庆一直在偷懒。昨天（7号）晚上试着提交了一下，然后用custom test得出的正确答案逆推了一下，结果，就是发现了锯齿形这个东西。不怕题难，就怕看错题。现在题意弄清楚了，我们开始吧。</p><p>我用两种方法实现了，第一种是比较容易想到的：既然是锯齿形的，那我用一个二维数组记录字符存储的位置就好了。二维数组先全部初始化为-1，再把字符在字符串中的位置序号按锯齿形填进去。这里比较难的就是这个二维数组的第二维长度，下面是第二维长度numColumns的计算公式，其中length是给定的字符串的长度，numRows是给定的行数即第一维长度。</p><p>numColumns = length / (2 <em> numRows - 2) </em> (numRows - 1) + (length % (2 <em> numRows - 2) == 0 ? 0 :  (length % (2 </em> numRows - 2) &gt; numRows ? length % (2 * numRows - 2) - numRows + 1 : 1));</p><p>首先length / (2 <em> numRows - 2)是锯齿形中完整锯齿 V的个数（隐式强制转换，即商取整），然后乘上(numRows - 1) 得到的是除去最后一个不完整的锯齿V（若存在），最后一个不完整的锯齿V如果只有第一条边，则加1；如果含有V的第二条边，则加length % (2 </em> numRows - 2) - numRows + 1。</p><p>这种方法的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</div><div class="line">    String ans = <span class="string">""</span>;</div><div class="line">    <span class="keyword">int</span> i, j, k = <span class="number">0</span>, map[][], numColumns, length = s.length();</div><div class="line">    numColumns = length &lt; numRows? length : length / (<span class="number">2</span> * numRows - <span class="number">2</span>) * (numRows - <span class="number">1</span>)</div><div class="line">      + (length % (<span class="number">2</span> * numRows - <span class="number">2</span>) == <span class="number">0</span> ? <span class="number">0</span> : (length % (<span class="number">2</span> * numRows - <span class="number">2</span>) &gt; numRows ?</div><div class="line">        length % (<span class="number">2</span> * numRows - <span class="number">2</span>) - numRows + <span class="number">1</span> : <span class="number">1</span>));</div><div class="line">    map = <span class="keyword">new</span> <span class="keyword">int</span>[numRows][numColumns];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numColumns; j++) &#123;</div><div class="line">            map[i][j] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    i = j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (k &lt; length) &#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; numRows - <span class="number">1</span> &amp;&amp; k &lt; length) &#123;</div><div class="line">            map[i++][j] = k++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; numColumns &amp;&amp; k &lt; length) &#123;</div><div class="line">            map[i--][j++] = k++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numColumns; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (map[i][j] != -<span class="number">1</span>) &#123;</div><div class="line">              ans += s.charAt(map[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我们来介绍第二种方法，这种方法不按图形规律去算， 而是按数字规律去算，即最后输出的字符串中每个字符在原给定字符串中的位置序号的规律。这里就不再阐述了，留给读者自己观察发现。</p><p>这种方法的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</div><div class="line">    String ans = <span class="string">""</span>;</div><div class="line">    <span class="keyword">int</span> i, j, length = s.length();</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = i; j &lt; length; j += <span class="number">2</span> * numRows -<span class="number">2</span>) &#123;</div><div class="line">            ans += s.charAt(j);</div><div class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &amp;&amp; j + <span class="number">2</span> * numRows - <span class="number">2</span> * i - <span class="number">2</span> &lt; length) &#123;</div><div class="line">                ans += s.charAt(j + <span class="number">2</span> * numRows - <span class="number">2</span> * i - <span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;锯齿形转换&quot;&gt;&lt;a href=&quot;#锯齿形转换&quot; class=&quot;headerlink&quot; title=&quot;锯齿形转换&quot;&gt;&lt;/a&gt;锯齿形转换&lt;/h2&gt;&lt;p&gt;字符串“PAYPALISHIRING”以给定数字的行数被写入锯齿形图案：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;P   A   H   N&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;A P L S I I G&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Y   I   R&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后逐行读取得“PAHNAPLSIIGYIR”。&lt;/p&gt;
&lt;p&gt;给定一个字符串，并给出了一个行数，&lt;/p&gt;
&lt;p&gt;string convert(string text, int nRows);&lt;/p&gt;
&lt;p&gt;如convert(“PAYPALISHIRING”, 3)这个转换应返回“PAHNAPLSIIGYIR”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
      <category term="Algorithm" scheme="https://egoistk21.xyz/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://egoistk21.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Longest Palindromic Substring</title>
    <link href="https://egoistk21.xyz/2016/09/23/Longest%20Palindromic%20Substring/"/>
    <id>https://egoistk21.xyz/2016/09/23/Longest Palindromic Substring/</id>
    <published>2016-09-23T15:27:11.000Z</published>
    <updated>2017-09-28T01:20:46.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长回文字符子串"><a href="#最长回文字符子串" class="headerlink" title="最长回文字符子串"></a>最长回文字符子串</h2><p>给定一个字符串S，找出S中最长的回文字符子串。</p><p>一开始我想用递归，现检验整个字符串longestPalindrome(String s)，若非回文字，则调用自身，传入s.subString(1, s.length)和s.subString(0, s.length - 1)，即不断的左减一，右减一，检验其子串是否回文字。但是我想不好怎么接收return值，所以就用了很水的方法来检验，即对于遍历的每一个字符，检查其左右是否为回文字，这样的回文字判断也分奇数长度的和偶数长度的，如“121”和“1221”。具体实现代码如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</div><div class="line">    String longerPalindrome = <span class="string">""</span>;</div><div class="line">    <span class="keyword">int</span> length = s.length(), i, j, k;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>)==s.charAt(i)) &#123;</div><div class="line">            j = i - <span class="number">1</span>;</div><div class="line">            k = i;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>&amp;&amp;k &lt; length) &#123;</div><div class="line">                <span class="keyword">if</span> (s.charAt(j) == s.charAt(k)) &#123;</div><div class="line">                    j--;</div><div class="line">                    k++;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((k - j - <span class="number">1</span>) &gt; longerPalindrome.length()) &#123;</div><div class="line">                longerPalindrome = s.substring(j + <span class="number">1</span>, k);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; length - <span class="number">1</span>&amp;&amp;s.charAt(i - <span class="number">1</span>)==s.charAt(i + <span class="number">1</span>)) &#123;</div><div class="line">            j = i - <span class="number">1</span>;</div><div class="line">            k = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>&amp;&amp;k &lt; length) &#123;</div><div class="line">                <span class="keyword">if</span> (s.charAt(j) == s.charAt(k)) &#123;</div><div class="line">                    j--;</div><div class="line">                    k++;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((k - j - <span class="number">1</span>) &gt; longerPalindrome.length()) &#123;</div><div class="line">                longerPalindrome = s.substring(j + <span class="number">1</span>, k);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> longerPalindrome;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>这样的方法竟然给水过了，我想去学习一下字符串匹配的KMP算法，以后有机会在博客中分享。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最长回文字符子串&quot;&gt;&lt;a href=&quot;#最长回文字符子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文字符子串&quot;&gt;&lt;/a&gt;最长回文字符子串&lt;/h2&gt;&lt;p&gt;给定一个字符串S，找出S中最长的回文字符子串。&lt;/p&gt;
&lt;p&gt;一开始我想用递归，现检验整个字符串longestPalindrome(String s)，若非回文字，则调用自身，传入s.subString(1, s.length)和s.subString(0, s.length - 1)，即不断的左减一，右减一，检验其子串是否回文字。但是我想不好怎么接收return值，所以就用了很水的方法来检验，即对于遍历的每一个字符，检查其左右是否为回文字，这样的回文字判断也分奇数长度的和偶数长度的，如“121”和“1221”。具体实现代码如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
      <category term="Algorithm" scheme="https://egoistk21.xyz/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://egoistk21.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Java排序算法专题</title>
    <link href="https://egoistk21.xyz/2016/09/10/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    <id>https://egoistk21.xyz/2016/09/10/Java排序算法专题/</id>
    <published>2016-09-09T16:12:20.000Z</published>
    <updated>2017-09-28T01:20:46.613Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上做了一下LeetCode上的<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="external">Median of Two Sorted Arrays</a>这道题，没想到一次性通过了。随即想要归纳整理一下排序算法，废话少说，我们开始吧。</p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>这是一种最简单直观的排序算法，它的工作原理如下：每一趟从待排序的数列中选出最小的（最大的）一个元素，顺序放到已经排好序的数列的最后，直到所有待排元素全部排好。选择排序是<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E5.88.86.E9.A1.9E" target="_blank" rel="external">稳定的排序算法</a>，最坏<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="external">时间复杂度</a>是O(n^2)，最优时间复杂度是O(n^2)，平均时间复杂度是O(n^2)。</p><p>下面是对{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}进行选择排序的具体过程</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">|1 3 5 7 9 2 4 6 8 0  选择第一小的数与0位交换</div><div class="line"> i j</div><div class="line">1 3 5 7 9 2 4 6 8 0</div><div class="line">i                 j</div><div class="line">                 min</div><div class="line">0| 3 5 7 9 2 4 6 8 1  选择第二小的数与1位交换</div><div class="line">   i j</div><div class="line">0 3 5 7 9 2 4 6 8 1</div><div class="line">  i               j</div><div class="line">                 min</div><div class="line">0 1| 5 7 9 2 4 6 8 3  选择第三小的数与2位交换</div><div class="line">0 1 2| 7 9 5 4 6 8 3  选择第四小的数与3位交换</div><div class="line">0 1 2 3| 9 5 4 6 8 7  选择第五小的数与4位交换</div><div class="line">0 1 2 3 4| 5 9 6 8 7  选择第六小的数与5位交换</div><div class="line">0 1 2 3 4 5| 9 6 8 7  选择第七小的数与6位交换</div><div class="line">0 1 2 3 4 5 6| 9 8 7  选择第八小的数与7位交换</div><div class="line">0 1 2 3 4 5 6 7| 8 9  选择第九小的数与8位交换</div><div class="line">0 1 2 3 4 5 6 7 8| 9  待排只剩一个数，排序结束</div></pre></td></tr></table></figure><p>选择排序(从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> min, temp, length = nums.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[min] &gt; nums[j]) &#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = nums[i];</div><div class="line">        nums[i] = nums[min];</div><div class="line">        nums[min] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>这也是一种简单直观的排序算法，它的工作原理如下：构建有序序列，即对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序是稳定的排序算法，最坏时间复杂度是O(n^2)，最优时间复杂度是O(n)，平均时间复杂度是O(n^2)。</p><p>下面是对{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}进行插入排序的具体过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">1 3 5 7 9 2 4 6 8 0</div><div class="line">1 3 5 7 9 9 4 6 8 0  temp=2</div><div class="line">1 3 5 7 7 9 4 6 8 0</div><div class="line">1 3 5 5 7 9 4 6 8 0</div><div class="line">1 3 3 5 7 9 4 6 8 0</div><div class="line">1 2 3 5 7 9 4 6 8 0</div><div class="line">1 2 3 5 7 9 9 6 8 0  temp=4</div><div class="line">1 2 3 5 7 7 9 6 8 0</div><div class="line">1 2 3 5 5 7 9 6 8 0</div><div class="line">1 2 3 4 5 7 9 6 8 0</div><div class="line">1 2 3 4 5 7 9 9 8 0  temp=6</div><div class="line">1 2 3 4 5 7 7 9 8 0</div><div class="line">1 2 3 4 5 6 7 9 8 0</div><div class="line">1 2 3 4 5 6 7 9 9 0  temp=8</div><div class="line">1 2 3 4 5 6 7 8 9 0</div><div class="line">1 2 3 4 5 6 7 8 9 9  temp=0</div><div class="line">1 2 3 4 5 6 7 8 8 9</div><div class="line">1 2 3 4 5 6 7 7 8 9</div><div class="line">1 2 3 4 5 6 6 7 8 9</div><div class="line">1 2 3 4 5 5 6 7 8 9</div><div class="line">1 2 3 4 4 5 6 7 8 9</div><div class="line">1 2 3 3 4 5 6 7 8 9</div><div class="line">1 2 2 3 4 5 6 7 8 9</div><div class="line">1 1 2 3 4 5 6 7 8 9</div><div class="line">0 1 2 3 4 5 6 7 8 9</div></pre></td></tr></table></figure><p>插入排序(从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp, length = nums.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">        temp = nums[i];</div><div class="line">        <span class="keyword">int</span> j = i;</div><div class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">1</span>&amp;&amp;temp &lt; nums[j - <span class="number">1</span>]; j--) &#123;</div><div class="line">            nums [j] = nums[j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        nums[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。我把希尔排序叫做分组插入排序，它的工作原理如下：先把要排序的序列元素以序列长度的1/2为间隔(向下取整)两两分为一组，对每组分别进行插入排序，排完后再以序列长度的1/4为间隔(向下取整)分组，对每组分别进行插入排序，重复上述操作，直至间隔为一，即最后一趟为普通的插入排序(此时序列已基本有序)。希尔排序是不稳定的排序算法，时间复杂度取决于分组间隔gap的取值，目前最佳版本的最坏时间复杂度是O(n(lgn)^2)。一般情况下，最坏时间复杂度是O(n^2)，最优时间复杂度是O(n)。</p><p>下面是对{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}进行插入排序的具体过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1 3 5 7 9 2 4 6 8 0  gap=5</div><div class="line">1 3 5 7 9 2 4 6 8 9  temp=0</div><div class="line">1 3 5 7 0 2 4 6 8 9  gap=2</div><div class="line">1 3 5 7 5 2 4 6 8 9  temp=0</div><div class="line">1 3 1 7 5 2 4 6 8 9</div><div class="line">0 3 1 7 5 2 4 6 8 9</div><div class="line">0 3 1 7 5 2 5 6 8 9  temp=4</div><div class="line">0 3 1 7 4 2 5 6 8 9</div><div class="line">0 3 1 7 4 7 5 6 8 9  temp=2</div><div class="line">0 3 1 3 4 7 5 6 8 9</div><div class="line">0 2 1 3 4 7 5 6 8 9</div><div class="line">0 2 1 3 4 7 5 7 8 9  temp=6</div><div class="line">0 2 1 3 4 6 5 7 8 9  gap=1</div><div class="line">0 2 2 3 4 6 5 7 8 9  temp=1</div><div class="line">0 1 2 3 4 6 5 7 8 9</div><div class="line">0 1 2 3 4 6 6 7 8 9  temp=5</div><div class="line">0 1 2 3 4 5 6 7 8 9</div></pre></td></tr></table></figure><p>希尔排序(从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp, length = nums.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = length/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gap ; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + gap; j &lt; length; j += gap) &#123;</div><div class="line">                temp = nums[j];</div><div class="line">                <span class="keyword">int</span> k = j;</div><div class="line">                <span class="keyword">for</span> (; k &gt;= gap&amp;&amp;temp &lt; nums[k - gap]; k -= gap) &#123;</div><div class="line">                    nums[k] = nums[k - gap];</div><div class="line">                &#125;</div><div class="line">                nums[k] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序，是一种简单的排序算法。因其排序过程中较大(或小)元素会慢慢“浮到”顶部，就像鱼吐泡泡而得名。它的工作原理如下：重复地遍历要排序的序列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，直到序列有序。冒泡排序是稳定的排序算法，最坏时间复杂度是O(n^2)，最优时间复杂度是O(n)，平均时间复杂度是O(n^2)。</p><p>下面是对{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}进行冒泡排序的具体过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">|1 3 5 7 9 2 4 6 8 0</div><div class="line">|1 3 5 7 9 2 4 6 0 8</div><div class="line">|1 3 5 7 9 2 4 0 6 8</div><div class="line">|1 3 5 7 9 2 0 4 6 8</div><div class="line">|1 3 5 7 9 0 2 4 6 8</div><div class="line">|1 3 5 7 0 9 2 4 6 8</div><div class="line">|1 3 5 0 7 9 2 4 6 8</div><div class="line">|1 3 0 5 7 9 2 4 6 8</div><div class="line">|1 0 3 5 7 9 2 4 6 8</div><div class="line">0 1| 3 5 7 9 2 4 6 8</div><div class="line">0 1| 3 5 7 2 9 4 6 8</div><div class="line">0 1| 3 5 2 7 9 4 6 8</div><div class="line">0 1| 3 2 5 7 9 4 6 8</div><div class="line">0 1 2 3| 5 7 9 4 6 8</div><div class="line">0 1 2 3| 5 7 4 9 6 8</div><div class="line">0 1 2 3| 5 4 7 9 6 8</div><div class="line">0 1 2 3 4 5| 7 9 6 8</div><div class="line">0 1 2 3 4 5| 7 6 9 8</div><div class="line">0 1 2 3 4 5 6 7| 9 8</div><div class="line">0 1 2 3 4 5 6 7 8 9|</div></pre></td></tr></table></figure><p>冒泡排序(从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> length = nums.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt; i; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[j - <span class="number">1</span>] &gt; nums[j]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = nums[j - <span class="number">1</span>];</div><div class="line">                nums[j - <span class="number">1</span>] = nums[j];</div><div class="line">                nums[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(nlogn)次比较。在最坏状况下则需要Ο(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。快速排序是不稳定的排序算法，最坏时间复杂度是O(n^2)，最优时间复杂度是O(nlogn)，平均时间复杂度是O(nlogn)。</p><p>下面是对{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}进行快速排序(递归版)的具体过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">                     第一遍循环</div><div class="line">                     取pivot=1</div><div class="line">                     1 3 5 7 9 2 4 6 8 0</div><div class="line">                     i                 j</div><div class="line">                     先从尾部j开始，找到比1小的数字往i的位置复制</div><div class="line">                     0 3 5 7 9 2 4 6 8 0</div><div class="line">                       i               j</div><div class="line">                     0比1小，被复制到i的位置，复制之后i++</div><div class="line">                     0 3 5 7 9 2 4 6 8 3</div><div class="line">                       i             j</div><div class="line">                     这时候要从头部i开始，找到比1大的数字往j的位置复制</div><div class="line">                     3比1大，被复制到j的位置，复制之后j--</div><div class="line">                     0 3 5 7 9 2 4 6 8 3</div><div class="line">                       i</div><div class="line">                       j</div><div class="line">                     再次从j开始寻找比1小的数字，但是没找到，直到i和j相遇（i=j）</div><div class="line">                     第一遍循环结束</div><div class="line">                     0 1 5 7 9 2 4 6 8 3</div><div class="line">                     把pivot复制到循环结束时i的位置</div><div class="line">                     此时pivot把数组分成两部分&#123;0&#125;和&#123;5, 7, 9, 2, 4, 6, 8, 3&#125;</div><div class="line">                  </div><div class="line">                第二次循环分两部分进行</div><div class="line">                </div><div class="line">第一部分                                     第二部分</div><div class="line">0                                          取pivot=5</div><div class="line">只有一个数，不用排序                           5 7 9 2 4 6 8 3</div><div class="line">第一部分结束                                 i             j</div><div class="line">                                           和第一遍循环一样先从j开始...</div><div class="line">                                            3 7 9 2 4 6 8 3</div><div class="line">                                              i           j</div><div class="line">                                            3 7 9 2 4 6 8 7</div><div class="line">                                              i         j</div><div class="line">                                            3 4 9 2 4 6 8 7</div><div class="line">                                                i   j</div><div class="line">                                            3 4 9 2 9 6 8 7</div><div class="line">                                                i</div><div class="line">                                                  j</div><div class="line">                                            3 4 2 2 9 6 8 7</div><div class="line">                                                  i</div><div class="line">                                                  j</div><div class="line">                                            3 4 2 5 9 6 8 7</div><div class="line">                                            第二遍循环结束</div><div class="line">                                            只有第二部分进行第三次循环</div><div class="line">                                            此时pivot把数组分成两部分&#123;3, 4, 2&#125;和&#123;9, 6, 8, 7&#125;</div><div class="line">                                            不断循环，排序，分组，直到最后每一组都只剩1个数</div><div class="line">               最后“将所有组合并”（实际上数组没有分组，只是每次对部分数据进行操作）</div><div class="line">               得到&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</div></pre></td></tr></table></figure><p>快速排序(递归版、从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveQuickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = head, j = tail;</div><div class="line">    <span class="keyword">int</span> pivot = nums[head];</div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">            <span class="keyword">if</span> (pivot &gt;= nums[j]) &#123;</div><div class="line">                nums[i++] = nums[j];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">            <span class="keyword">if</span> (pivot &lt;= nums[i]) &#123;</div><div class="line">                nums[j--] = nums[i];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    nums[i] = pivot;</div><div class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> - head &gt; <span class="number">0</span>) &#123;</div><div class="line">        recursiveQuickSort(nums, head, i - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (tail - i - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">        recursiveQuickSort(nums, i + <span class="number">1</span>, tail);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong><a href="http://egoistk21.xyz/2017/02/17/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E7%BB%AD/#快速排序">快速排序非递归版</a></strong></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="external">Median of Two Sorted Arrays</a>这道题我用的排序法就是归并排序，归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。它的原理如下：先申请一个空间用于存储排序后的序列，大小为两个已经排序的序列大小之和。在两个已经排序的序列头部分别放置指针，比较指针所指元素的大小，较小的(或较大的)复制到刚刚申请的新序列空间，该指针后移，重复比较、复制到新序列尾部、后移指针，直到遍历完其中一个序列，则另一个序列的剩余元素全部原序复制到新序列尾部。归并排序是稳定的排序算法，最坏时间复杂度是O(nlogn)，最优时间复杂度是O(n)，平均时间复杂度是O(nlogn)，需要O(n)额外空间。</p><p>下面是对{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}进行归并排序(递归版)的具体过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                      &#123;1 3 5 7 9 2 4 6 8 0&#125;</div><div class="line">第一层递归         &#123;1 3 5 7 9&#125;    |     &#123;2 4 6 8 0&#125;</div><div class="line">第二层递归       &#123;1 3 5&#125; | &#123;7 9&#125;  |   &#123;2 4 6&#125; | &#123;8 0&#125;</div><div class="line">第三层递归     &#123;1 3&#125; |&#123;5&#125;|&#123;7&#125;|&#123;9&#125; |  &#123;2 4&#125;|&#123;6&#125;|&#123;8&#125;|&#123;0&#125;</div><div class="line">第四层递归    &#123;1&#125;|&#123;3&#125;|&#123;5&#125;|&#123;7&#125;|&#123;9&#125; |&#123;2&#125;|&#123;4&#125;|&#123;6&#125;|&#123;8&#125;|&#123;0&#125;</div><div class="line">第一层归并     &#123;1 3&#125; |&#123;5&#125;| &#123;7 9&#125;  |  &#123;2 4&#125;|&#123;6&#125;| &#123;0 8&#125;</div><div class="line">第二层归并       &#123;1 3 5&#125; | &#123;7 9&#125;  |   &#123;2 4 6&#125; | &#123;0 8&#125;</div><div class="line">第三层归并         &#123;1 3 5 7 9&#125;    |     &#123;0 2 4 6 8&#125;</div><div class="line">第四层归并              &#123;0 1 2 3 4 5 6 7 8 9&#125;</div></pre></td></tr></table></figure><p>归并排序(递归版、从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> head, <span class="keyword">int</span> median, <span class="keyword">int</span> tail)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] nums1 = <span class="keyword">new</span> <span class="keyword">int</span>[median - head + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[tail - median];</div><div class="line">    <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</div><div class="line">    System.arraycopy(nums, head, nums1, <span class="number">0</span>, length1);</div><div class="line">    System.arraycopy(nums, median + <span class="number">1</span>, nums2, <span class="number">0</span>, length2);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = head;</div><div class="line">    <span class="keyword">while</span> (i &lt; length1&amp;&amp;j &lt; length2) &#123;</div><div class="line">        nums[k++] = (nums1[i] &lt; nums2[j])?nums1[i++]:nums2[j++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (i &lt; length1) &#123;</div><div class="line">        nums[k++] = nums1[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (j &lt; length2) &#123;</div><div class="line">        nums[k++] = nums2[j++];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveMergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> median = (head + tail)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (median != tail) &#123;</div><div class="line">        recursiveMergeSort(nums, head, median);</div><div class="line">        recursiveMergeSort(nums, median + <span class="number">1</span>, tail);</div><div class="line">    &#125;</div><div class="line">    merge(nums, head, median, tail);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong><a href="http://egoistk21.xyz/2017/02/17/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E7%BB%AD/#归并排序">归并排序非递归版</a></strong></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序，是指利用堆这种数据结构所设计的一种排序算法。堆排序的时间复杂度为O(nlogn)，是不稳定的排序算法，且具有空间原址性：任何时候都只需要常数个额外的元素空间存储临时数据。<br><a href="http://www.cnblogs.com/skywang12345/p/3610390.html" target="_blank" rel="external">二叉堆图文介绍 参考</a></p><p><a href="http://www.cnblogs.com/skywang12345/p/3602162.html" target="_blank" rel="external">堆排序图文介绍 参考</a></p><p>堆排序(大根堆、从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> p = head, l = <span class="number">2</span>*p + <span class="number">1</span>, r = l + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> tmp = nums[p];</div><div class="line">    <span class="keyword">for</span> (; l &lt;= tail; p = l,l = <span class="number">2</span>*l + <span class="number">1</span>,r = l + <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (l &lt; tail &amp;&amp; nums[l] &lt; nums[r]) &#123;</div><div class="line">            l = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (tmp &gt;= nums[l]) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            nums[p] = nums[l];</div><div class="line">            nums[l]= tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, tmp, length = nums.length;</div><div class="line">    <span class="keyword">for</span> (i = length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        maxHeapDown(nums, i, length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        tmp = nums[<span class="number">0</span>];</div><div class="line">        nums[<span class="number">0</span>] = nums[i];</div><div class="line">        nums[i] = tmp;</div><div class="line">        maxHeapDown(nums, <span class="number">0</span>, i - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>以上7种常见排序都是基于比较的排序，基于比较的排序的时间复杂度的极限是O(nlogn)，下面我给大家介绍三种基于计算的排序算法，它们都是线性的，时间复杂度为O(n)。</strong></p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序的思想特别简单，就是找出所给序列中最大的元素，新建一个大小为最大元素加一的序列并初始化为全0，所给序列中元素的大小与新建的序列的下标相对应，遍历所给序列，每遇到一个元素，以这个元素为下标的新序列的元素就自加1。桶排序是稳定的排序算法，时间复杂度为O(n)，需要O(k)额外空间。</p><p>下面我们分析一下对数组{1, 3, 5, 7, 9, 2, 4, 6, 8, 0， 0}进行桶排序的过程</p><p>1、遍历所给数组得到最大元素9</p><p>2、新建一个长度为9+1的数组，并初始化为全0 {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}</p><p>3、遍历所给数组，遇到第一个元素1，将新建数组中下标为1的元素自加1 {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}</p><p>4、同理，遇到第二个元素3，将新建数组中下标为3的元素自加1 {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0}</p><p>5、遍历完成后，新数组为 {2, 1, 1, 1, 1, 1, 1, 1, 1, 1}</p><p>6、遍历新数组，当遇到非零元素时，为所给数组赋予非零元素个的下标的值，如非零元素2，下标为0，则对所给序列的前两个元素赋值0</p><p>桶排序(从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxElemOfNums</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</div><div class="line">            max = nums[i] + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> length = nums.length, max = maxElemOfNums(nums), i, j;</div><div class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        bucket[nums[i]]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; max; i++) &#123;</div><div class="line">        <span class="keyword">while</span> ((bucket[i]--) &gt; <span class="number">0</span>) &#123;</div><div class="line">            nums[j++] = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序是对桶排序的一种改进，其基本思想是：对于给定序列中的元素x，确定小于(大于)x的元素个数。利用这一信息，可以直接把x放到它在输出序列中的位置上。计数排序是稳定的排序算法，时间复杂度为O(n+k)，需要O(n+k)额外空间。</p><p>计数排序(从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> length = nums.length, max = maxElemOfNums(nums), i, j;</div><div class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">    System.arraycopy(nums, <span class="number">0</span>, temp, <span class="number">0</span>, length);</div><div class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        bucket[temp[i]]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; max; i++) &#123;</div><div class="line">        bucket[i] += bucket[i - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        nums[bucket[temp[i]] - <span class="number">1</span>] = temp[i];</div><div class="line">        bucket[temp[i]]--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是对计数排序的一种改进，它是这样实现的：将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序(计数排序)。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。基数排序是稳定的排序算法，时间复杂度为O(kn)，需要O(n)额外空间。</p><p>基数排序(从小到大)的Java实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> exp, length = nums.length, max = maxElemOfNums(nums), i;</div><div class="line">    <span class="keyword">for</span> (exp = <span class="number">1</span>; (max - <span class="number">1</span>)/exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[max];</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">            buckets[(nums[i]/exp)%<span class="number">10</span>]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; max; i++) &#123;</div><div class="line">            buckets[i] += buckets[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            temp[buckets[(nums[i]/exp)%<span class="number">10</span>] - <span class="number">1</span>] = nums[i];</div><div class="line">            buckets[(nums[i]/exp)%<span class="number">10</span>]--;</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(temp, <span class="number">0</span>, nums, <span class="number">0</span>, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天晚上做了一下LeetCode上的&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Median of Two Sorted Arrays&lt;/a&gt;这道题，没想到一次性通过了。随即想要归纳整理一下排序算法，废话少说，我们开始吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h3&gt;&lt;p&gt;这是一种最简单直观的排序算法，它的工作原理如下：每一趟从待排序的数列中选出最小的（最大的）一个元素，顺序放到已经排好序的数列的最后，直到所有待排元素全部排好。选择排序是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E5.88.86.E9.A1.9E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;稳定的排序算法&lt;/a&gt;，最坏&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;时间复杂度&lt;/a&gt;是O(n^2)，最优时间复杂度是O(n^2)，平均时间复杂度是O(n^2)。&lt;/p&gt;
&lt;p&gt;下面是对{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}进行选择排序的具体过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
      <category term="Algorithm" scheme="https://egoistk21.xyz/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://egoistk21.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Longest Substring Without Repeating Characters</title>
    <link href="https://egoistk21.xyz/2016/09/06/Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <id>https://egoistk21.xyz/2016/09/06/Longest Substring Without Repeating Characters/</id>
    <published>2016-09-06T08:44:22.000Z</published>
    <updated>2017-09-28T01:20:46.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长无重字符子串"><a href="#最长无重字符子串" class="headerlink" title="最长无重字符子串"></a>最长无重字符子串</h2><p>给定一个字符串，找到最长子串的长度不重复的字符。</p><p>例子：</p><p>给定“abcabcbb”，答案是“abc”，它的长度为3。</p><p>给定“bbbbb”，答案为“b”，长度为1。</p><p>给定“pwwkew”，答案是“wke”，长度为3。</p><p>注意答案一定是一个字符串的长度，“pwke”是一个序列，而不是子串。<br><a id="more"></a></p><hr><p>这是我第一遍刷算法题，也是第一遍刷Leetcode。碰到这个字符串的问题，一开始我有点懵，这对我太有难度了。但是我忍住没有去看Editorial，一点点自己码。嗯，这是一个好的开端。</p><p>题目要求我们获得最长无重子串，所以我从最长入手，用一个变量currLength从最长子串开始递减，再用两个变量i，j遍历currLength子串中是否有重复字符，若有则currLength自减，若无则返回currLength为最长无重子串的长度。若字符串本身长度小于2则直接返回字符串本身长度。但是测试数据的时候出现了问题，原来我忘了考虑currLength自减后，currLength长度的子串不止一个。比如“abcabcbb”的长度为8，它的长度为7的子串有“abcabcb”和“bcabcbb”，两个。所以我又加了一层循环用来<strong>滑动</strong>currLength的子串。</p><p>下面就是我的第一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> length = s.length(), currLength = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> length;</div><div class="line">    <span class="comment">//滑动字符子串长度currLength</span></div><div class="line">    <span class="keyword">for</span> (currLength = length; currLength &gt; <span class="number">1</span>; currLength--) &#123;</div><div class="line">        <span class="comment">//滑动字符子串位置head</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> head = <span class="number">0</span>; head &lt;= length - currLength; head++) &#123;</div><div class="line">            <span class="comment">//滑动字符子串内遍历查询重复字符</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; head + currLength - <span class="number">1</span>; i++) &#123;</div><div class="line">                c = s.charAt(i);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; head + currLength; j++) &#123;</div><div class="line">                    <span class="comment">//如果遍历中遇到重复字符，则跳出循环，字符子串右移一位</span></div><div class="line">                    <span class="keyword">if</span> (c == s.charAt(j)) &#123;</div><div class="line">                        flag = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (flag) &#123;</div><div class="line">                    flag = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果遍历结束,字符子串内无重复字符，返回当前长度currLength</span></div><div class="line">                <span class="keyword">if</span> (i == head + currLength - <span class="number">2</span>) <span class="keyword">return</span> currLength;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> currLength;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是这段代码提交后被rejected了。原因是时间复杂度太大，当遇到字符串本身超长且最长无重子串较短时，所需计算时间太长。四层循环，时间复杂度为O(n^4)。所以我需要改进我的算法，从减少循环层数开始，我称之为更加线性化的算法。</p><p>这次我从第一个字符开始，用<strong>双指针</strong>的方法，双指针首先指向第m个和第n个字符（m&lt;n），若不相同则尾指针右移；若相同则头指针右移跳出比较循环同时尾指针也右移，因为尾指针所指字符只和头指针所指字符相同，头指针所指字符和<strong>头指针与尾指针之间的字符</strong>都不相同。另外当遍历到最后一个字符的时候，返回maxLength和currLength中较长者。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">1</span>, curr, length = s.length(), currLength = <span class="number">0</span>, maxLength = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) <span class="keyword">return</span> length;</div><div class="line">    <span class="comment">//线性遍历整个字符串s，每次遇到重复字符，记录当前无重字符子串长度并与maxLength比较取大，字符子串头部head右移一位</span></div><div class="line">    <span class="keyword">for</span> (; head &lt; length - currLength; head++) &#123;</div><div class="line">        <span class="keyword">for</span> (; tail &lt; length; tail++) &#123;</div><div class="line">            c = s.charAt(tail);</div><div class="line">            <span class="keyword">for</span> (curr = head; curr &lt; tail; curr++) &#123;</div><div class="line">                <span class="keyword">if</span> (c == s.charAt(curr)) &#123;</div><div class="line">                    currLength = tail - head;</div><div class="line">                    maxLength = (maxLength &gt; currLength)?maxLength:currLength;</div><div class="line">                    head = curr + <span class="number">1</span>;<span class="comment">//head重定位</span></div><div class="line">                                   <span class="comment">//tail不重新赋值，也会自加，相当于++tail </span></div><div class="line">                    flag = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (flag) &#123;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (tail == length - <span class="number">1</span> &amp;&amp; curr == tail) &#123;</div><div class="line">                currLength = tail - head + <span class="number">1</span>;</div><div class="line">                <span class="keyword">return</span> (maxLength &gt; currLength)?maxLength:currLength;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxLength;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这次提交后总算accepted了，<strong>爽！</strong></p><p>但是隐约中我觉得还有更好的算法，但是目前自己技术有限，等以后再来填坑～</p><p><strong>谢谢阅读</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最长无重字符子串&quot;&gt;&lt;a href=&quot;#最长无重字符子串&quot; class=&quot;headerlink&quot; title=&quot;最长无重字符子串&quot;&gt;&lt;/a&gt;最长无重字符子串&lt;/h2&gt;&lt;p&gt;给定一个字符串，找到最长子串的长度不重复的字符。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;给定“abcabcbb”，答案是“abc”，它的长度为3。&lt;/p&gt;
&lt;p&gt;给定“bbbbb”，答案为“b”，长度为1。&lt;/p&gt;
&lt;p&gt;给定“pwwkew”，答案是“wke”，长度为3。&lt;/p&gt;
&lt;p&gt;注意答案一定是一个字符串的长度，“pwke”是一个序列，而不是子串。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://egoistk21.xyz/tags/Java/"/>
    
      <category term="Algorithm" scheme="https://egoistk21.xyz/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://egoistk21.xyz/tags/LeetCode/"/>
    
  </entry>
  
</feed>
